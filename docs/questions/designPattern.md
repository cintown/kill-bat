# 设计模式

## 单例模式

### 懒汉式饿汉式模板写法对比

|           懒汉式           |      饿汉式      |
| :------------------------: | :--------------: |
|        私有构造函数        |   私有构造函数   |
| 私有 volatile 静态成员对象 |   私有静态对象   |
|                            |      静态块      |
|      共有静态工厂方法      | 共有静态工厂方法 |

### 懒汉式 sychronized 锁住的是什么

1. sychronized 关键字添加在静态方法上锁住的 class 文件，添加在非静态方法上锁住的堆内存中的对象
2. 懒汉式 sychronized 锁住是类

### 懒汉式为什么要双重检查

第一重检查：

由于在静态方法中加入 sychronized，锁住的还是类对象，影响范围比较大。所以可以在已有单例的情况下直接返回这个单例

第二重检查：

如不加入第二重检查，多个进入到第一重检查的线程（对象还是 null），被 sychronized 阻塞。若获取到同步锁的线程创建好了对象，那么这些被阻塞的线程其实并没有获取到对象，就直接返回了

### 哪一种单例模式最安全

用枚举类实现的单例

## 原型模式

### 标志

clone()

### 什么是浅克隆什么是深克隆(待完善)

浅克隆：

1. 属性中无对象

深克隆：

2. 属性中有对象

## 享元模式

### 描述

池概念

## 装饰者模式

### 标志

super(抽象父类对象)

### 描述

对原有对象添加或减少功能

## 代理对象

### 静态代理实现

代理类和实体类共同继承同一个接口，在代理类构造方法中传入实体类对象，代理类中调用实体类中的方法，并可以在调用前后添加切片

### 静态代理的缺点

接口类中添加一个方法，实体类和代理类都需要改动，难扩展

### 动态代理实现

1.jdk 动态代理（基于接口）

- 实现 InvocationHandler 接口
- invoke 反射

  2.cglib（基于继承）

- 实现 MethodInceptor 接口
- invokeSuper 代理类中调用父类（实体类）（cglib 会自动构造一个该类的子类）
- enhance 调用

> 指定父类（实体类） -> setSuperClass()
>
> 指定代理类 -> setCallback()
>
> 调用 -> create()

### spring AOP 中使用的是那种动态代理

spring AOP 多数情况下使用 cglib，只有当代理是接口或本身已用 jdk 动态代理实现，才会使用 jdk 动态代理

## 责任链模式

### 描述

- A 调用 B，B 调用 C
- 可用 List 封装这三个对象，实现动态的链式调用





<comment-comment/>