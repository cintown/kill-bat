# Redis

## Redis 架构模型

### 主从复制模型

1. 主从复制模型中，有多个 redis 节点。其中，有且仅有一个为主节点。从节点 Slave 可以有多个。Master 会一直将自己的数据更新同步给 Slaves，保持主从同步。
2. 主节点 Master 可读可写，从节点 Slave 只读
3. redis.conf 中配置 slaveof Master 的 ip 端口
4. 缺陷：Master 宕机了，整个集群就没有可写的节点了

### 哨兵模式 Sentinel

Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance），执行以下认为

1. 监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。
2. 提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。
3. 自动故障迁移（Automatic failover）：

- 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会进行选举(Sentinel 个数为基数，选举采用多数原则)，将其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器
- 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。

4. sentinel.conf 中配置 sentinel moniter 主节点别名 主节点地址 端口 触发故障切换的最少哨兵数

## Redis 有哪几种数据类型

1. String

2. Hash

3. List (FILO)

4. Set

5. Sorted set

## Redis 如何持久化

1.RDB 持久化：将 redis 在内存中的数据记录定时 dump 到磁盘上

方式：实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储

2.AOF 持久化：将 redis 的操作日志以追加的方式写入文件

方式：以日志的形式记录服务器所处理的每一个写、删除操作，查询操作都会以文本的方式记录，可以打开文件看到详细的操作记录

## Redis 分布式锁

## Redis 内存淘汰机制

```xml
redis.conf

# maxmemory-policy volatile-lru
```

1. noeviction `默认`：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。

2. allkeys-lru `推荐`：在主键空间中，优先移除最近未使用的 key。

3. volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的 key。

4. allkeys-random：在主键空间中，随机移除某个 key。

5. volatile-random：在设置了过期时间的键空间中，随机移除某个 key。

6. volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。

## Redis 如何处理缓存穿透问题

缓存穿透：请求缓存中不存在的数据，导致所有的请求都直接请求到数据库上，从而数据库连接异常

1. 互斥锁，先获取锁再请求数据库，否则休眠一段时间重试

2. 异步更新策略，维护缓存失效时间，如果缓存过期，则启动异步线程读数据库更新缓存。请求无论 key 的值是否取到，都直接返回

3. 提供一个能迅速判断请求是否有效的拦截机制，如利用布隆过滤器

## Redis 如何处理缓存雪崩问题

缓存雪崩：缓存同一时间大面积的失效，这个时候又来了一波请求，导致请求直接请求到数据库上，引发数据库连接异常

1. 使用互斥锁，但该方案吞吐量明显下降

2. 给缓存的失效时间，加上一个随机值，避免集体失效

3. 双缓存













<comment-comment/>